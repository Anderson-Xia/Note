# Bitcoin

---
### Sharer: Lingling Lu

---
## Motivation

 传统货币是中心化的，依赖于可信第三方。比特币这一概念提出的目的即为实现无需中心机构参与的货币交易。

## Challenge

 由于不存在中心数据库的记录，如何保证比特币没有被多次花费成为了一个挑战，即"双花问题"。

## Solution

为了解决最基本的双花问题，保证交易的一致性，btc采用了pow共识，使用分布式账本记录交易。

在没有第三方的情况下，交易必须被全网广播。一个系统里面所有参与者只对在一个单链的历史顺序达成共识。收款人需要确保，当一笔交易出现时，这笔交易是大多数节点公认第一次出现的。从而保证交易的可靠性。

### UTXO模型

UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易生成及验证的一个核心概念。交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前向一个或多个交易的输出，这些链条的源头都是挖矿奖励，末尾则是当前未花费的交易输出。

比特币规定每一笔新的交易的输入必须是某笔交易未花费的输出，每一笔输入同时也需要上一笔输出所对应的私钥进行签名，并且每个比特币的节点都会存储当前整个区块链上的UTXO，整个网络上的节点通过UTXO及签名算法来验证新交易。

### POW机制

 POW机制基于密码学难题实现工作量证明。矿工想要记账（构建区块），需要计算nounce以保证账单的哈希值满足特定要求，作为其工作量证明。该要求会被系统动态修改难度，以保证比特币流通的稳定。一旦账单被大多数结点验证为正确，则并入主链。

### 区块链分叉

 由于全局通过广播机制传递消息具有时延，不同的结点本地维护的区块链可能会不同，导致区块链分叉。因此区块链会定期检查，将最长的区块链同步到全局，在其他链上的交易会随之撤销，需要重新计算。

## 相关研究方向调研

1. 跨链查询 —— Fabric联盟链，以太坊公链，比特币公链
2. 数据挖掘，分布式图聚类，账户特征识别


# IoT Fuzzing 

---
### Sharer: Peiyu Liu

---

## Scope

---

### 主要固件类型

1. 通用OS: 如Linux, Android

   >Q1: 通用OS 如linux 是否已经成为IoT设备系统选择的趋势？
   > 
   >A1: 有调查指出 Linux base OS 使用率很高。包括常用的电视等

   >Q2: 上述Linux架构一般是什么？
   > 
   >A2: 大多数Mips, ARM其次

2. 嵌入式Linux OS: FreeRTOS

3. Without OS: TinyOS
---
## Workflow

<img src="/Users/xiayifan/Desktop/一个计算机博士的自我修养/DailyNote/2021_11_21/2021112101.png" alt="图片替换文本" width="300" height="400" align="bottom" />

---

## Preparation (准备阶段)

### challenge

1. IoT设备的硬件/系统资源有限

    solution: Rehosting -- 即在PC上使用模拟器模拟IoT环境

2. PC模拟器缺失真实环境的相关依赖（如传感器）

    solution1 : Partial Emulating

   使用重定向等方式将硬件请求发送到真实硬件并获取反馈，交付给模拟器，再由模拟器反馈给固件

   缺点: 需要真实设备支持，因此很难大规模运用，且开销较大导致吞吐量较低

    solution2 :  Full Emulating

   模拟虚拟硬件以满足相应的依赖

   缺点: 需要大量人力工作

---

## Black-box fuzzing

### motivation

因为上述模拟方式开销过大，且新型设备无法模拟，研究人员开始考虑转而使用黑盒fuzzing以增加效率。

### Challenges

 1. 难以生成合法输入（i.格式要求 ii.加密信息）

    solution:

      IOTFUZZER NDSS'18: 使用IoT设备的伴生App, 在应用端对数据source进行变异,由伴生应用对数据进行格式化

      DIANE S&P'21: 提出上述IOTFUZZER的变异阶段应当在App的format check过程之后，以绕过检验。

 2. Monitoring (如何监测设备状态)

      #### Problem 1: 判断是否发生crash

      solution:

       1. 使用心跳包探测，如果没有收到response则认为发生了crash

          

      #### Problem 2: Silent memory corruptions 
      
       触发Bug不一定会造成IoT设备的Crash

       solution: 没有非常好的解决方案，可能的解决方案如内存监控。

 3. Feedback（缺乏反馈机制）
   
       solution:
   
     > 1.Snipuzz : 提出通过response信息获取反馈。
    > 
     > 2.使用符号执行技术获取覆盖率信息
   
      

## Future Direction

### Preparation阶段

	竞争较激烈，可以考虑针对模拟成功率较低的特殊场景做针对性研究。

### 数据生成阶段

	Sensor中存在非传统的Input, 可以从这方面入手，模拟物理现象的出现，以探索多样的状态。

### Execution阶段

	使用并行方式增加吞吐量。

### Feedback阶段

    尝试实现state-aware的反馈，指导fuzzing决策。

### Analysis阶段

    1.自动化分析
    2.Bug Report 优先级评估。


>Q3: 近期相关工作趋向？
> 
>A3: 目前多为黑盒，很少有人继续做模拟工作。此前的工作只实现了模拟环境就不再继续探索了，Fuzzing过程多使用previous work。

>Q4: 能否将传感器驱动转换为binary进行fuzzing？
> 
>A4: 目前的工作都避开了传感器模拟，这部分工作是区别于传统Fuzzing的，可以尝试。且传感器种类较多，可以先针对特定类型设备进行研究。

>Q5: 传感器状态太少，是否很难做fuzzing？
>
>A5: 不只是为了找传感器漏洞，可以从传感器自底向上传递信息，探索更多内核状态。

>Q6: 目前IoT Fuzzing的目标程序是什么？
>
>A6.1: 目前IoT Fuzzing目前探索的都是表层代码，如网络层，未涉及到底层逻辑。
>
>A6.2: 网络层代码和用户输入有关，较易被利用。其他部分用户无法利用，可能不存在攻击面。

> Q7: 用户相关的输入是否覆盖完全？
>
> A7: 没有，DIANE特别提到提到IOTFUZZER覆盖的输入类型不全。

>Insight1: 对Sensor反馈的物理环境信息变异，覆盖更diverse的代码逻辑。
> 
> Insight2: 针对用户相关输入未能覆盖完全这一问题，开展一项工作，全面覆盖可能的用户输入类型。

>Q8: Emulation 的目的是否是获取反馈？
>
>A8: 是很重要的一个motivation.

>Q9: sensor的输入是否会映射到内存中？能否直接在内存中进行变异？
>
>A9: 很难操作IoT内存，实现上存在问题。

>Q10: 由于存在对传感器输入的约束，很难变异出异常值，是否会导致工作无用？
>
>A10: 不需要得到异常值，只需要通过不同的sensor input获取更diverse的执行路径。

>Insight3: 对具体场景进行分析，关注sensor数据影响主程序执行的场景

>Q11: Monitor阶段的监控是否是实时的？能否进行内存监控？
> 
>A11: 是一个可行的思路。



